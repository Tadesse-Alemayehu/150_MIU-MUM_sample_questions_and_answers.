/* this code's are writen and compiled by Tadesse Alemayehu 
- for any question you might have you can drop it on my email "tadAlem@gmail.com"
- or contact me a@ 
        akypee "adesu.alemayehu1" 
        telegram "@jaBrainiac" 
        twitter "@AddisuAlemayeh8"
        website "https://winmacsoul.com/"
        phone "+251921577930"
*/
// part two with 60 functions 

package miu.com.pro.collection2;

public class MIUComProCollection2 {

    public static void main(String[] args) {
        
        MIUComProCollection2 mainObject=new MIUComProCollection2();
//        System.out.println(mainObject.isVesuvian(65));
//        System.out.println(mainObject.isOneBalanced(new int[]{1,1,1,2,3,-18,45,1}));
//        System.out.println(mainObject.isFibonacci(13));
//        System.out.println(mainObject.isTriangular(10));
//        System.out.println(mainObject.isMercurial(new int[]{2, 3, 1, 1, 18}));
//        System.out.println(mainObject.is235Array(new int[]{3, 9, 27, 7, 1, 1, 1, 1, 1}));
//            for(int element: mainObject.computeHMS(3650)){
//                System.out.println(element);
//            }
//        System.out.println(mainObject.isMartian(new int[]{1, 3}));
//        System.out.println(mainObject.isPairedN(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8},5));
//        System.out.println(mainObject.isNPrimeable(new int[]{1, 1, 1, 1, 1, 1, 1},4));
//
//
//
//        System.out.println(mainObject.is121Array(new int[]{1,1, 1, 2, 2,2, 1, 1, 1}));
//            for(int element: mainObject.pairwiseSum(new int[]{2, 1, 18, -5, -5, -15, 0, 0, 1, -1})){
//                /* giving an odd number of element or an array with length of less than two
//                will cause an exception scince the return will be null*/
//                System.out.println(element);
//            }
//        System.out.println(mainObject.isSquare(25));
//        System.out.println(mainObject.isComplete(new int[]{3, 7, 23, 13, 107, -99, 97, 81}));
//        System.out.println(mainObject.loopSum(new int[]{1, 4, 5, 6},4));
//        System.out.println(mainObject.allValuesTheSame(new int[]{432123456}));
//        System.out.println(mainObject.sameNumberOfFactors(23,97));
//        System.out.println(mainObject.eval(2,new int[]{4, 0, 9}));
//        System.out.println(mainObject.isAllPossibilities(new int[]{1, 2, 0, 3}));
//        System.out.println(mainObject.isLayered(new int[]{1, 1, 2, 2, 2, 3, 3}));
//
//
//
//            for(int element: mainObject.updateMileageCounter(new int[]{9, 9, 9, 9, 9, 9, 9, 9, 9, 9},1)){
//                System.out.println(element);
//            }
//        System.out.println(mainObject.isHollow(new int[]{1,1,1,1,0,0,0,0,0,0,2,1,2,18}));
//        System.out.println(mainObject.isConsectiveFactored(24));
//        System.out.println(mainObject.isTwinPrime(53));
//        System.out.println(mainObject.largestAdjacentSum2(new int[]{1, 2, 3, 4})); 
//        System.out.println(mainObject.isZeroBalanced(new int[]{0, 0, 0, 0, 0, 0}));
//        System.out.println(mainObject.findSmallestBEQnumber());
//        System.out.println(mainObject.isZeroLimited(new int[]{1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0}));
//        System.out.println(mainObject.isCubePerfect(new int[]{3, 7, 21, 36}));
//        System.out.println(mainObject.countOnes(15));
//        System.out.println(mainObject.isDaphne(new int[]{1,3,17,-5}));
//
//
//
//
//        System.out.println(mainObject.isOddValent(new int[]{3, 3, 3, 3}));
//        System.out.println(mainObject.isNormal(7));
//        System.out.println(mainObject.isAllPossibilities2(new int[]{1, 2, 0, 3}));
//        System.out.println(mainObject.isFilter(new int[]{4, 7, 13}));
//        System.out.println(mainObject.isDigitSum(32121,10));
//        System.out.println(mainObject.isFineArray(new int[]{4, 7, 9, 6, 5}));
//        System.out.println(mainObject.isBalanced(new int[]{-2, 2, -2,0}));
//        System.out.println(mainObject.isEvens(2464264));
//        System.out.println(mainObject.isMagicArray(new int[]{8, 5, -5, 5, 3}));
//        System.out.println(mainObject.isComplete2(new int[]{-5, 6, 2, 3, 2, 4, 5, 11, 8, 7}));
//
//
//
//
//        System.out.println(mainObject.isPrimeProduct(22));
//        System.out.println(mainObject.isBalanced2(new int[]{6, 7, 2, 3, 12}));
//        System.out.println(mainObject.isCentered(new int[]{3, 2, 1, 4, 5}));
//        System.out.println(mainObject.hasKSmallFactors(7,30));
//        System.out.println(mainObject.is235Array(new int[]{3, 9, 27, 7, 1, 1, 1, 1, 1}));
//            for(int element: mainObject.fill(new int[]{1,2,3,5, 9, 12,-2,-1},3,10)){
//                System.out.println(element);
//            }
//        System.out.println(mainObject.isHollow2(new int[]{1,1,1,1,0,0,0,2,1,2,18}));
//        System.out.println(mainObject.isConsectiveFactored2(90));
//        System.out.println(mainObject.isTwinPrime2(9));
//        System.out.println(mainObject.largestAdjacentSum3(new int[]{1, 2, 3, 4})); 
//
//
//
//        System.out.println(mainObject.isZeroBalanced2(new int[]{3, -3, -3}));
//        System.out.println(mainObject.findSmallestBEQnumber2());
//        System.out.println(mainObject.isZeroLimited2(new int[]{1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0}));
//        System.out.println(mainObject.isOddValent2(new int[]{8, 8, 8, 4, 4, 7, 2}));
//        System.out.println(mainObject.isNormal2(6));
//        System.out.println(mainObject.minDistance(13013));
//        System.out.println(mainObject.isWave(new int[]{7, 2, 9, 10, 5}));
//        System.out.println(mainObject.isBean(new int[]{4, 7, 16}));
//        System.out.println(mainObject.countDigit(33331, 3));
//        System.out.println(mainObject.isBunkerArray(new int[]{4, 9, 6, 7, 3}));
       
    }
    
int isVesuvian(int n){
    for(int i=1;(i*i)<n;i++){
        int sq=i*i;
        int sumSq=0;
        for(int k=1;sumSq<n;k++)
            sumSq=sq+(k*k);
        if(sumSq==n)
            return 1;
    }
    return 0;
}

//

int isOneBalanced(int[ ] a){
int begin1=0,end1=0,oNum=0;

for(int i=0;i<a.length;i++){
    if(end1!=0&&a[i]!=1)
        return 0;
    else if(a[i]==1&&oNum==0)
        begin1++;
    else if(a[i]!=1)
        oNum++;
    else if(oNum!=0&&a[i]==1)
        end1++;
}
if((begin1+end1)!=oNum)
    return 0;
else 
    return 1;
}

//

int isFibonacci(int n){
int temp=1;
int ff=1,sf=1,nf=ff+sf;
for(; nf<n;temp=sf){
    sf=ff+sf;
    ff=temp;
    nf=ff+sf;
}
if(n==nf)
    return 1;
else 
    return 0;
}

//

int isTriangular(int n){
int sum=0;
        for(int i=1;sum<n;i++)
            sum+=i;
        if(sum==n)
            return 1;
        else 
            return 0;
}

//

int isMercurial(int[ ] a){
    boolean is3found=false;
int begin1=0;
for(int i=0;i<a.length;i++){
    if(a[i]==1&&(!is3found))
        begin1++;
    else if(a[i]==3&&begin1!=0)
        is3found=true;
    else if(a[i]==1&&is3found)
        return 0;
}
  return 1;  
}

//

int is235Array(int[ ] a){
int dby2=0,dby3=0,dby5=0,ndby235=0;
    for(int i=0;i<a.length;i++){
        if(a[i]%2!=0&&a[i]%3!=0&&a[i]%5!=0)
            ndby235++;
        else {
            if(a[i]%2==0)
                dby2++;
            if(a[i]%3==0)
                dby3++;
            if(a[i]%5==0)
                dby5++;
        }
    }
if((dby2+dby3+dby5+ndby235)==a.length)
    return 1;
else 
    return 0;
}

int[] computeHMS(int seconds){
int second=seconds%60;
int minute=seconds/60;
int hour=minute/60;
minute=minute%60;
return new int[]{hour,minute,second};
}

//

int isMartian(int[ ] a){
int no1=0,no2=0;
for(int i=0;i<a.length;i++){
    if(a[i]==1)
        no1++;
    else if(a[i]==2)
        no2++;
    if(i==(a.length-1))
        break;
    else if(a[i]==a[i+1])
        return 0;
}
if(no1>no2)
    return 1;
else 
    return 0;
}

//

int isPairedN(int[ ] a, int n){
if(a.length-1+a.length-2<n||a.length<2)
    return 0;
for(int i=0;i<a.length&&i<=n;i++){
    if(a[i]>n)
        continue;
    for(int k=0;k<a.length&&k<=n;k++){
        if(k!=i&&k+i==n&&a[i]+a[k]==n)
            return 1;
    }
}
return 0;
}

//

int isNPrimeable(int[ ] a, int n){
for(int i=0;i<a.length;i++){
    int num=a[i]+n;
    for(int k=2;k<num;k++){
        if(num%k==0)
            return 0;
    }
}
return 1;
}

//

int is121Array(int[ ] a){
if(a[0]!=1||a[a.length-1]!=1)
    return 0;
int begin1=0,end1=0,twos=0;
for(int i=0;i<a.length;i++){
    if(a[i]==1&&twos==0)
        begin1++;
    else if(a[i]==2&&begin1!=0&&end1==0)
        twos++;
    else if(a[i]==1&&twos!=0&&begin1!=0)
        end1++;
    else 
        return 0;
}
if(begin1!=end1)
    return 0;
else return 1;
}

//

int[ ] pairwiseSum(int[ ] a){
if(a.length%2!=0||a.length<2)
    return null;
int[] pair=new int[a.length/2];
for(int i=0,j=0;i<a.length;i+=2,j++){
    pair[j]=a[i]+a[i+1];
}
return pair;
}

//

int isSquare(int n){
int i=1;
for(;(i*i)<n;i++){
}
if((i*i)==n)
    return 1;
else 
    return 0;
}

//

int isComplete(int[ ] a){
    if(a.length<2)
        return 0;
boolean even=false;
boolean perfectS=false;
boolean sum8=false;
for(int i=0;i<a.length;i++){
if(!even&&a[i]%2==0)
    even=true;
if(!perfectS){
    int ps=1;
    for(int k=1;ps<a[i];k++)
        ps=k*k;
    if(ps==a[i])
        perfectS=true;
}
if(!sum8){
for(int l=i;l<a.length;l++){
    if(a[i]+a[l]==8&&i!=l)
        sum8=true;
}
if(even&&perfectS&&sum8)
    return 1;
}
}
return 0;
}

//

int loopSum(int[ ] a, int n){
int sum=0;
for(int i=0;n>0;i++){
if(i==a.length)
        i=0;
     sum+=a[i];
     n--;
}
return sum;    
}

//

int allValuesTheSame(int[ ] a){
int val=a[0];
for(int i=0;i<a.length;i++)
    if(a[i]!=val)
        return 0;
return 1;
}

//

int hasNValues(int[ ] a, int n){
int[] clone=new int[a.length];
int count=0;
boolean isZeroCount=false;
for(int i=0;i<a.length;i++){
    if(a[i]==0){
        if(!isZeroCount)
        {
            count++;
            isZeroCount=true;
        }
    }
    else {
        boolean beenCount=false;
        for(int k=0;k<clone.length;k++){
            if(clone[k]==a[i])
            {
                beenCount=true;
            }
        }
    if(!beenCount)
    {
        count++;
        clone[i]=a[i];
        if(count>n)
            return 0;
    }
    }
}
if(count==n)
    return 1;
else 
    return 0;
}

//

int sameNumberOfFactors(int n1, int n2){
if(n1<0||n2<0)
    return -1;
int fact1=0,fact2=0;
for(int i=1;i<=n1||i<=n2;i++){
    if(n1%i==0)
        fact1++;
    if(n2%i==0)
        fact2++;
}
if(fact1==fact2)
    return 1;
else 
    return 0;
}

//

double eval(double x, int[ ] a){
int sum=0,pow=0;
for(int i=0;i<a.length;i++,pow++){
    sum+=a[i]*Math.pow(x,i);
}
return sum;
}

//

int isAllPossibilities(int[ ] a){
for(int i=0;i<a.length;i++){
 boolean found=false;
    for(int k=0;k<a.length;k++){
        if(a[k]==i){
            found=true;
            break;
        }
    }
    if(!found)
        return 0;
}
return 1;
}

//

int isLayered(int[ ] a){
    if(a.length<2||a[0]!=a[1]||a[a.length-1]!=a[a.length-2])
        return 0;
    for(int i=0;i<(a.length-1);i++){
        int count=1;
        boolean otherElement=false;
        for(int j=(i+1);j<a.length;j++){
            if(a[i]==a[j]&&(!otherElement))
            {
            count++;
            i++;
            }
            else if(a[j]<a[i])
                return 0;
            else 
                otherElement=true;
        }
        if(count<2)
            return 0;
    }
return 1;
}

int[] updateMileageCounter(int[ ] a, int miles){
int div=miles;
for(int i=0;i<a.length&&div>0;i++){
int mod=(a[i]+div)%10;
div=(a[i]+div)/10;
a[i]=mod;
}
return a;// method suppose to be void but for the sec of simplicity i make it int[]
}

//

int isHollow(int[ ] a){
if(a.length<3)
    return 0;
int middle=a.length/2;
int i=middle-1;
int j=middle+1;
if(a.length%2==0)
{j=middle;}
boolean otherNumber=false;
if(a[i]!=0||a[j]!=0||a[middle]!=0)
    return 0;
i--;
j++;
for(;i>=0&&j<a.length;i--,j++){
    if(otherNumber&&(a[i]==0||a[j]==0))
        return 0;
    else if((a[i]==0||a[j]==0)&&a[i]!=a[j])
        return 0;
    else if(a[i]!=0&&a[j]!=0)
        otherNumber =true;   
}
return 1;
}

//

int isConsectiveFactored(int n){

for(int i=2;i<n;i++){
    if(n%i==0)
    {
        int j=i+1;
        if(n%j==0)
            return 1;
    }

} 
    return 0;
}

//

int isTwinPrime(int n){
boolean m2=true,p2=true;
for(int i=2;i<(n+2);i++){
    if(i>=n&&m2)
        return 1;
    else if(n%i==0&&i!=n)
        return 0;
    if((n-2)%i==0&&i!=(n-2))
        m2=false;
    if((n+2)%i==0)// the loop will terminate before it touch this so no need for "i!=(n+2)"
        p2=false;
    if(!m2&&!p2)
        return 0;
}
return 1; 
}

//

int largestAdjacentSum2(int[ ] a){
int adjacentS=a[0]+a[1];
for(int i=1;i<(a.length-1);i++){
    if(a[i]+a[i+1]>adjacentS)
        adjacentS=a[i]+a[i+1];
}
return adjacentS;
}

//

int isZeroBalanced(int[ ] a){
int sum=0;
for(int i=0;i<a.length;i++){
    if(a[i]==0)
        continue;
    sum+=a[i];
    boolean inverse=false;
    for(int k=0;k<a.length;k++){
        if(a[i]+a[k]==0){
            inverse=true;
        }
        
    }
    if(!inverse)
        return 0;
}
if(sum==0)
    return 1;
else return 0;
}

//

int findSmallestBEQnumber( ){
int BEQ=0;
for(int i=11;BEQ==0;i++){
    int num=i*i*i;
    int sixCount=0;
    for(int k=num;k>0;k/=10){
        if(k%10==6)
            sixCount++;
    }
 if(sixCount==4){
     BEQ=i;
 }
}
return BEQ;
}

//

int isZeroLimited(int[ ] a){
for(int i=0,n=0;i<a.length;i++){
    if(i==(3*n+1)){
        if(a[i]!=0)
            return 0;
        n++;
    }
    else if(a[i]==0)
        return 0;
}
return 1;
}

int isCubePerfect(int[ ] a){
outerLoop:for(int i=0;i<a.length;i++){
int cub=0;
for(int j=0;cub<=Math.abs(a[i]);j++){
    cub=(j*j*j);
    if(cub==Math.abs(a[i]))
        continue outerLoop;
}
return 0;
}
return 1;
}

//

int countOnes(int n){
int once=0;
for(int i=n;i>0;i/=2){
    if(i%2!=0)
        once++;
}
return once;
}

//

int isDaphne (int[ ] a){
int odd=0,even=0;
for(int i=0;i<a.length;i++){
    if(a[i]%2==0)
        even++;
    else 
        odd++;
    if(odd!=0&&even!=0)
        return 0;
}
return 1;
}

//

int isOddValent (int[ ] a){
    boolean odd=false;
    boolean more=false;
    for(int i=0;i<a.length;i++){
        if(a[i]%2!=0)
            odd=true;
        if(!more){
        int count=0;
        for(int j=i;j<a.length;j++){
            if(a[i]==a[j]){
                count++;
                if(count>2){
                more=true;
                break;
                }
            }
        }
        }
        if(more&&odd)
            return 1;
    }
    return 0;
}

//

int isNormal(int n){
int maxFact=(n/2);
for(int i=3;i<=maxFact;i++){
    if(i%2!=0&&n%i==0)
        return 0;
}
return 1;
}

//

int isAllPossibilities2(int[ ] a){
    outerLoop:for(int i=0;i<a.length;i++){
        for(int j=0;j<a.length;j++){
        if(a[j]==i){
            continue outerLoop;
            }
        }
        return 0;    
    }
    return 1;
}

//

int isFilter(int[ ] a){
    outerLoop:for(int i=0;i<a.length;i++){
    if(a[i]!=9&&a[i]!=7)
        continue;
    for(int k=0;k<a.length;k++){
        if(a[i]==7&&a[k]==13)
            return 0;
        else if(a[i]==9&&a[k]==11)
            continue outerLoop;
    }
if(a[i]==9)
return 0;
}
    return 1;
}

//

int isDigitSum(int n, int m){
int sum=0;
    for(int i=n;i>0;i/=10){
        sum+=(i%10);
    }
if(sum<m)
    return 1;
else 
    return 0;
}

//
//helper function 
int isPrime(int n){
    for(int i=2;i<n;i++){
        if(n%i==0)
            return 0;
    }
return n>1?1:0;
}
int isFineArray (int [ ] a){
outerLoop:for(int i=0;i<a.length;i++){
	if(isPrime(a[i])==1){
	Boolean isPm2=isPrime(a[i]-2)==1;
	Boolean isPp2=isPrime(a[i]+2)==1;
	if(!(isPm2)&&!(isPp2))
        {return 0;}
	for(int k=0;k<a.length;k++){
		if(isPm2&&a[k]==(a[i]-2))
			continue outerLoop;
		else if(isPp2&&a[k]==(a[i]+2))
			continue outerLoop;
		}
	return 0;
	}
}
return 1;
}

//

int isBalanced(int [ ] a){
	outerLoop:for(int i=0;i<a.length;i++){
		for(int k=0;k<a.length;k++){
			if(a[i]+a[k]==0)
				continue outerLoop;
}
return 0;
}
        return 1;
}


//


int isEvens(int n) {
	for(int i=n;i>0;i/=10){
	if((i%10)%2!=0)
		return 0;
}
return 1;
}

//

int isMagicArray (int[ ] a) {
int sum=0;
for(int i=0;i<a.length&&sum<=a[0];i++){
if(isPrime(a[i])==1){
	sum+=a[i];
}
}
if(sum==a[0])
return 1;
else 
return 0;
}

//

int isComplete2 (int[ ] a) {
int min=0,max=0;
Boolean even=false;
for(int i=0;i<a.length;i++){
	if(a[i]%2!=0)
	continue;
	else if((! even)){
	even=true;
	min=i;
	max=i;
	}
	if(a[i]<a[min])
	min=i;
	else if(a[i]>a[max])
	max=i;
}
if((!even)||a[min]==a[max])
{return 0;}
outerLoop:for(int I=a[min];I<=a[max];I++){
	for(int j=0;j<a.length;j++){
	if(I==a[j])
	continue outerLoop;
}
return 0;
}
return 1;
}


//


int isPrimeProduct(int n){
for(int i=2;i<n;i++){
    if(isPrime(i)==1){
        int product=0;
        for(int j=i;i<n&&product<n;i++){
            if(isPrime(j)==1){
                product=i*j;
            }
        }
        if(product==n)
            return 1;
    }
}
return 0;
}

//

int isBalanced2(int[ ] a){
for(int i=0;i<a.length;i++){
    if(i%2==0&&a[i]%2!=0)
        return 0;
    else if(i%2!=0&&a[i]%2==0)
        return 0;
}
return 1;
}

//

int isCentered(int[ ] a){
if(a.length%2==0)
    return 0;
int middle=a.length/2;
for(int i=0;i<a.length;i++){
    if(a[i]<=a[middle]&&i!=middle)
        return 0;
}
return 1;
}

//

boolean hasKSmallFactors(int k, int n){
    for(int i=1;i<k;i++){
        int fact=0;
        for(int j=i;j<k&&fact<n;j++){
            fact=i*j;
        }
        if(fact==n)
            return true;
    }
    return false;
}

//

int[ ] fill(int[ ] arr, int k, int n){
if(k<=0||n<0)
    return null;
int[] arr2=new int[n];
for(int i=0,p=0;i<n;i++,p++){
    if(p==k)
        p=0;
    arr2[i]=arr[p];
    
}
return arr2;
}

int isHollow2(int[ ] a){
if(a.length<3)
    return 0;
int beforeZ=0,zero=0,afterZ=0;
for(int i=0;i<a.length;i++){
    if(afterZ!=0&&a[i]==0)
        return 0;
    else if(a[i]!=0&&zero==0)
        beforeZ++;
    else if(a[i]==0&&afterZ==0)
        zero++;
    else if(a[i]!=0&&zero!=0)
        afterZ++;
    else 
        return 0;
}
if(beforeZ==afterZ&&zero>2)
    return 1;
else 
    return 0;
}


//

int isConsectiveFactored2(int n){
    for(int i=2;i<n;i++)
        if(n%i==0&&n%(i+1)==0)
            return 1;
return 0;    
}

//

int isTwinPrime2(int n){
    boolean NMinus2=true,N=true,NPlus2=true;
    for(int i=2;i<(n-2);i++){
        if((n-2)%i==0){
            NMinus2=false;
            break;
        }
    }
    for(int i=2;i<n;i++){
    if(n%i==0){
        N=false;
        break;
    }
    }
    if(NMinus2&&N)
        return 1;
    for(int i=2;i<(n+2);i++){
        if((n+2)%i==0){
        NPlus2=false;
        break;
        }
    }
    if(N&&NPlus2)
        return 1;
    else 
    return 0;
}

//

int largestAdjacentSum3(int[ ] a){
int largestA=a[0]+a[1];
for(int i=1;i<(a.length-1);i++){
    if(a[i]+a[i+1]>largestA)
        largestA=a[i]+a[i+1];
}
    return largestA;
}

//

int isZeroBalanced2(int[ ] a){
    if(a.length<1)
        return 0;
int sum=0;
outerLoop:for(int i=0;i<a.length;i++){
    sum+=a[i];
    for(int j=0;j<a.length;j++){
        if(a[i]+a[j]==0)
            continue outerLoop;
    }
    return 0;
}
    if(sum==0)
        return 1;
    else 
        return 0;
}

//

int findSmallestBEQnumber2( ){
    /* since we know the smallest number with four digit in its qube is 10*10*10=1000
    we can start i from 10*/
int i=0;boolean smallest=false;
for(;!smallest;i++){
    int j=i*i*i,count=0;
    for(;j>10;j/=10){
        if(j%10==6)
            {
                count++;
            }
    }
    if(count==4){
        smallest=true;
    }
}
return i-1;
}

//

int isZeroLimited2(int[ ] a){
for(int i=0,n=0;i<a.length;i++){
   if(i==(3*n+1)){
       if(a[i]!=0){
           return 0;
       }
       else
       n++;
   }
   else if(a[i]==0)
       return 0;
}
return 1;
}

//

int isOddValent2(int[ ] a){
boolean odd=false,occureMore=false;
for(int i=0;i<a.length;i++){
    if((!odd)&&a[i]%2!=0)
        odd=true;
    if(!occureMore){
        int count=0;
        for(int k=i;k<a.length;k++){
            if(a[i]==a[k]){
            count++;
            if(count>1){
            occureMore=true;
            break;
            }
            }
                
        }
    }
    if(odd&&occureMore)
        return 1;
}
return 0;
}

//

int isNormal2(int n){
    for(int i=3;i<n;i+=2){
        if(n%i==0)
            return 0;
    }
    return 1;
}


//

int isFineArray2(int [ ] a){
    for(int i=0;i<a.length;i++){
        if(isPrime(a[i])==1){
            if(isPrime(a[i]-2)==1||isPrime(a[i]+2)==1)
                continue;
            else 
                return 0; 
        }
    }
    return 1;
}

//


int minDistance(int n){
int diff=0,pf=1;
for(int i=2;i<=n;i++){
    if(n%i==0){
        if(diff==0){
            diff=i-pf;
        }
        else if((i-pf)<diff) {
            diff=i-pf;
        }
        pf=i;
    }
    if(diff==1)
        return diff;
}
return diff;
}

int isWave (int [ ] a){
boolean odd=a[0]%2!=0?true:false;
for(int i=1;i<a.length;i++){
    if(odd&&a[i]%2!=0)
        return 0;
    else if((!odd)&&a[i]%2==0)
        return 0;
    odd=(!odd);
}
return 1;
}

//

int isBean (int[ ] a){
boolean n7=false,n9=false,n13=false,n16=false;
for(int i=0;i<a.length;i++){
    if(a[i]==7)
        n7=true;
    else if(a[i]==9)
        n9=true;
    else if(a[i]==13)
        n13=true;
    else if(a[i]==16)
        n16=true;
    if(n7&&n16)
        return 0;
}
if(n9){
    if(n13)
        return 1;
    else 
        return 0;
}
else 
    return 1;
}

int countDigit(int n, int digit){
int count=0;
for(int i=n;i>0;i/=10){
    if(i%10==digit)
        count++;
}
return count;
}

//

int isBunkerArray(int [ ] a){
boolean previousOdd=a[0]%2!=0?true:false;
for(int i=1;i<a.length;i++){
    if(previousOdd){
        if(isPrime(a[i])==1)
            return 1;
    }
    if(a[i]%2!=0)
        previousOdd=true;
    else 
        previousOdd=false;
}
return 0;
}

//




}
