/* this code's are writen and compiled by Tadesse Alemayehu 
- for any question you might have you can drop it on my email "tadAlem26@gmail.com"
- or contact me a@ 
        akypee "adesu.alemayehu1" 
        telegram "@jaBrainiac" 
        twitter "@AddisuAlemayeh8"
        website "https://winmacsoul.com/"
        phone "+251921577930"
*/
// part one with 60 functions 

package miu.com.pro.collection;

public class MIUComProCollection {

    public static void main(String[] args) {
        MIUComProCollection mainObject=new MIUComProCollection();
//        System.out.println(mainObject.nextPerfectSquare(0));
//        System.out.println(mainObject.n_upCount(new int[]{2,3,1,-6,8,-3,-1,2},5));
//        System.out.println(mainObject.primeCount(11,29));
//        System.out.println(mainObject.isMadhavArray(new int[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, -2, -1}));
//        System.out.println(mainObject.isInertial(new int[]{-2, -4, -6, -8, -11}));
//        System.out.println(mainObject.countSquarePairs(new int[]{9}));
//        System.out.println(mainObject.PorcupineNumber(139));
//        System.out.println(mainObject.isGuthrieSequence(new int[]{8, 4, 2, 1}));
//        System.out.println(mainObject.stantonMeasure(new int[]{1, 3, 1, 1, 3, 3, 2, 3, 3, 3, 4}));
//        System.out.println(mainObject.sumFactor(new int[]{3, 0, 2, -5, 0}));
//
//        System.out.println(mainObject.guthrieIndex(3));
//        System.out.println(mainObject.solve10()[1]);
//        System.out.println(mainObject.repsEqual(new int[]{3,2,0, 5, 3},32053));
//        System.out.println(mainObject.isCentered15(new int[]{1, 1, 15 -1,-1}));
//        System.out.println(mainObject.henry(1,3));
//        System.out.println(mainObject.isDivisible(new int[]{3, 3, 6, 36},3));
//        System.out.println(mainObject.isNUnique(new int[]{7,3,3,2,4},11));
//        System.out.println(mainObject.isSquare(16));
//        System.out.println(mainObject.isLegalNumber(new int[]{3, 7, 1}, 6));
//        System.out.println(mainObject.convertToBase10(new int[]{3, 7, 1}, 6));
//
//
//        System.out.println(mainObject.haseNoZeroes(new int[]{3, 0, 1}));
//        System.out.println(mainObject.computerDepth(7));
//        System.out.println(mainObject.matches(new int[]{1, 2, 3, -5, -5, 2, 3, 18},new int[]{3, -2, 3}));1, 9, 12
//        System.out.println(mainObject.isStacked(4));
//        System.out.println(mainObject.isSumSafe(new int[]{5, -5, 0}));
//        System.out.println(mainObject.isIsolated(163));
//        System.out.println(mainObject.isVanilla(new int[]{9, 999, 99999, -9999}));
//        System.out.println(mainObject.isTrivalent(new int[]{1, 2, 2, 2, 2, 2, 2}));
//        System.out.println(mainObject.isSequentiallyBounded(new int[]{0, 1}));
//        System.out.println(mainObject.isMinMaxDisjoint(new int[]{5, 4, 1, 3, 2}));
//
//
//        System.out.println(mainObject.smallest(4));
//            for(int element: mainObject.clusterCompression(new int[]{1,1,1,2,1,1,1,3,3,4})){
//                System.out.println(element);
//            }
//        System.out.println(mainObject.isRailroadTie(new int[]{1, 2, 0, 1, 2, 0, 1, 2}));
//        System.out.println(mainObject.fullnessQuotient(360));
//        System.out.println(mainObject.isPacked(new int[]{7,7,7,7,7,7,7}));
//        System.out.println(mainObject.isOddHeavy(new int[]{2,4,6,8}));
//        System.out.println(mainObject.getExponent(128,4));
//        System.out.println(mainObject.is121Array(new int[]{1, 1, 2, 1, 2, 1, 1}));
//        for(int element: mainObject.filterArray(new int[]{0, 9, 12, 18, -6},1)){
//            System.out.println(element);
//        }
//        System.out.println(mainObject.largestAdjacentSum(new int[]{18, -12, 9, -10}));
//
//
//
//        System.out.println(mainObject.checkConcatenatedSum(13332,4));
//        System.out.println(mainObject.isSequencedArray(new int[]{1, 2, 5},1,5));
//        System.out.println(mainObject.largestPrimeFactor(6936));
//        for(int element: mainObject.encodeNumber(1200)){
//            System.out.println(element);
//        }
//        System.out.println(mainObject.matchPattern(new int[]{1, 1, 1, 2, 2, 1, 1, 3},8,new int[]{1, 2, 1, 3},4));
//        mainObject.doIntegerBasedRounding(new int[]{-18, 1, 2, 3, 4, 5},4);
//        System.out.println(mainObject.isCubePowerful(371));
//        System.out.println(mainObject.decodeArray(new int[]{-1, 5, 8, 17, 15}));
//        System.out.println(mainObject.isZeroPlentiful(new int[]{1, 2, 0, 0, 0, 0, 2, -18, 0, 0, 0, 0, 0, 12}));
//        System.out.println(mainObject.isDigitIncreasing(984));
//
//
//
//        System.out.println(mainObject.decodeArray2(new int[]{0, 1, 1, 1, 1, 1, 0, 1}));
//        System.out.println(mainObject.isOnionArray(new int[]{1, 2, 19, 4, 5}));
//        System.out.println(mainObject.isPrimeHappy(32));
//            for(int element: mainObject.encodeArray(-1)){
//                System.out.println(element);
//            }
//        System.out.println(mainObject.isSystematicallyIncreasing(new int[]{1, 1, 2,1,2, 3}));
//        System.out.println(mainObject.isFactorialPrime(3));
//        System.out.println(mainObject.largestDifferenceOfEvens(new int[]{1, 2, 1, 2, 1, 4, 1, 6, 4}));
//        System.out.println(mainObject.isHodder(127));
//        System.out.println(mainObject.areAnagrams(new char[]{'b', 'o', 'g'},new char[]{'b', 'o', 'o'}));
//        System.out.println(mainObject.closestFibonacci(34));
        System.out.println(mainObject.sumIsPower(new int[]{8,8,8,8}));
        
    }
int nextPerfectSquare(int n){
int nextPerfectSquare=0;
    for(int i=n;nextPerfectSquare==0;i++){
        for(int j=1;j<=i&&(j*j)<=i;j++){
            if((j*j)==i)
            {
                nextPerfectSquare=i;
                break;
            }
        
        }
    }

return nextPerfectSquare;
}

//

int n_upCount(int[] a, int n){
int upCount=0,preSum=0;
    for(int i=0;i<a.length;i++){
        int newSum=0;
        for(int j=0;j<=i;j++){
            newSum+= a[j];
        }
        if(preSum<=n&&newSum>n){
            upCount++;
        }
        preSum=newSum;
    }

return upCount;
    
}

//

int primeCount(int start, int end){
int primeCount=0;
    if(start<0)
        start=2;
    for(;start<=end;start++){
        boolean isPrime=true;
        for(int j=2;j<start;j++){
            if(start%j==0){
                isPrime=false;
                break;
            }
        }
      if(isPrime){
          primeCount++;
      }
    }
return primeCount;
}

//

int isMadhavArray(int[ ] a){
int j=0;
int num=a[j];
    for(int i=1;j<a.length;i++)
    {
        int sum=0;
        for(int l=1;l<=i;l++){
            if(j>=a.length)
                break;
            sum+=a[j];
            j++;
        }
       if(num!=sum)
           return 0;
    }        
return 1;
}

//

int isInertial(int[] a){
int maxIndex=0;
Boolean noOdd=true;
for(int i=0;i<a.length;i++){
if(noOdd&&a[i]%2!=0)
	noOdd=false;
if(a[i]>a[maxIndex])
	maxIndex=i;

}

for(int i=0;i<a.length;i++){
	if(a[i]%2==0)
		continue;
	for(int j=0;j<a.length;j++){
		if(a[j]%2!=0)
                    continue;
		else if(a[i]<=a[j]&&a[j]<a[maxIndex])
			return 0;
}
}
	return 1;
}

//

int isPerfectSquear(int n){
for(int i=1;i<n&&(i*i)<=n;i++){
    if((i*i)==n)
        return 1;
}
    return 0;
}
        
int countSquarePairs(int[ ] a){
int countPerfectSquare=0;
for(int i=0;i<a.length;i++){
        if(a[i]<=0)
        {continue;}
	for(int j=(i+1);j<a.length;j++){
		if(a[j]<=0)
			continue;
		if(isPerfectSquear(a[i]+a[j])==1&&a[i]!=a[j])
			countPerfectSquare++;
}
}

return countPerfectSquare;
}

//

int PorcupineNumber(int n){

Boolean isPorcupineNumber=false;
int PorcupineNumber=0;
for(int i=(n+1);(! isPorcupineNumber);i++)
{
	boolean isPrime=true;
		for(int j=2;j<i;j++){
			if(i%j==0){
			isPrime =false;
			}
		}
	if (isPrime&&i%10==9){
		if(PorcupineNumber!=0){
		 isPorcupineNumber=true;
			break;
		}
		else{
			PorcupineNumber=i;
		} 
	}
	else if(isPrime&&i%10!=9){
	PorcupineNumber=0;
	}	
}
return PorcupineNumber;

}

//

int isGuthrieSequence(int[ ] a){

    if(a[a.length-1]!=1)
        return 0;
    int num=a[0];
    for(int i=1;i<a.length;i++)
    {
        if(num%2==0)
        {
               num=num/2;
        }
        else{
            num=num*3+1;
        }
        if(a[i]!=num)
            return 0;
        if(num==1&&(i+1)!=a.length)
            return 0;
    }
    return 1;
}

//

int stantonMeasure(int[ ] a){
int stantonMesure=0,onceCount=0;
   for(int i=0;i<a.length;i++){
       if(a[i]==1)
           onceCount++;
    }
    for(int i=0;i<a.length;i++){
       if(a[i]==onceCount)
           stantonMesure++;
    }
return stantonMesure;
}

//

int sumFactor(int[ ] a){
int sumFactor=0,sum=0;
for(int i=0;i<a.length;i++){
    sum+=a[i];
}
for(int i=0;i<a.length;i++){
    if(a[i]==sum)
        sumFactor++;
}
return sumFactor;
}

//

int guthrieIndex(int n){
int guthrieIndex=0;
    for(int i=n;i>1;)
    {
        if(i%2==0){
        i=i/2;
        }
        else {
        i=i*3+1;
        }
        guthrieIndex++;
    }
return guthrieIndex;
}

//

int[ ] solve10(){
int fact10=1;
int[] factSum=new int[2]; 
for(int i=2;i<=10;i++)
    fact10 *=i;
for(int X=1;X<10;X++){
    int factX=1;
    for(int findFact=2;findFact<=X;findFact++)
        factX *=findFact;
    for(int Y=X;Y<10;Y++)
    {
        int factY=1;
        for(int findFact=2;findFact<=Y;findFact++)
            factY *=findFact;
        if((factX+factY)==fact10)
        {
           factSum[0]=X;
           factSum[1]=Y; 
           return factSum;
        }
    }
}
return factSum;
}

//

int repsEqual(int[ ] a, int n){
for(int i=(a.length-1);i>=0;i--)
{
    if(a[i]!=n%10)
        return 0;
    n /=10;
}
return 1;
}

//

int isCentered15(int[ ] a){
int nc=0,pc=0,middle=0;
    if(a.length%2==0){
        nc=a.length/2;
        pc=a.length/2-1;
    }
    else {
        middle=a.length/2;
        if(a[middle]==15)
            return 1;
        else{
            nc=middle+1;
            pc=middle-1;
        }
    }
    for(;pc>=0&&nc<a.length;pc--,nc++){
        int sum=0;
        for(int i=pc;i<=nc;i++)
        {
            sum+=a[i];
        }
        if(sum==15)
            return 1;
    }
    return 0;
}

//

int henry (int i, int j){
int perfectCount=0,perfectSum=0,big=0;
    if(i>j)
        big=i;
    else 
        big=j;
    for(int x=2;perfectCount<big;x++){
        int psum=1;
        for(int k=2;k<x;k++){
            if(x%k==0)
                psum+=k;
        }
        if(psum==x){
            perfectCount++;
            if(perfectCount==1||perfectCount==j)
            {
                perfectSum+=x;
            }
        }
    
    }
return perfectSum;
}

//

int isDivisible(int [ ] a, int divisor){

    for(int i=0;i<a.length;i++){
        if(a[i]%divisor!=0)
            return 0;
    }
return 1;
}

//

int isNUnique(int[ ] a, int n){
int countSum=0;

    for(int i=0;i<(a.length-1);i++){
        for(int j=(i+1);j<a.length;j++){
            if((a[i]+a[j])==n){
                countSum++;
                if(countSum>1)
                    break;
            }
            if(countSum>1)
                    break;
        }
    }
if(countSum==1)
    return 1;
else 
    return 0;
}

//

int isSquare(int n){
    for(int i=2;i<n&&(i*i)<=n;i++){
        if((i*i)==n)
            return 1;
    }
    return 0;
}

//

int isLegalNumber(int[ ] a, int base){
    for(int i=0;i<a.length;i++){
        if(a[i]>=base)
            return 0;
    }
    return 1;
}

int convertToBase10(int[ ] a, int base){
int number=0;
    if(isLegalNumber(a,base)==0)
        return -1;
    for(int i=(a.length-1),power=0;i>=0;i--,power++){
        number+=a[i]*Math.pow(base,power);
    }
return number; 
}

//

int haseNoZeroes(int[] a){
    for(int i=0;i<a.length;i++){
    if(a[i]==0)
        return 0;
    }
    return 1;
}

//

int computerDepth(int n){
int depth=0;
int[] nums={-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
int count=0;
    for(int i=1;count<nums.length;i++,depth++){
        for(int mult=n*i;mult>0;mult/=10){
              int digit=mult%10;
              if(nums[digit]==-1){
                  nums[digit]=digit;
                  count++;
              }
        }
    }
return depth;
}

//

int matches(int[ ] a, int[ ] p){
int max=0;
int j=0;

for(int i=0;i<p.length;i++){
Boolean isNegative=false;
if(p[i]<0)
{isNegative=true;}
max+=Math.abs(p[i]);
if(max>a.length)
{return 0;}
for(;j<max;j++)
{
if(isNegative&&a[j]>0)
return 0;
else if((!isNegative)&&a[j]<0)
return 0;
}
}
return 1;
}

//

int isStacked(int n){
int sum=0;

    for(int i=1;i<n&&sum<n;i++){
        sum+=i;
    }
if(sum==n)
    return 1;
else 
return 0;
}

//

int isSumSafe(int[ ]a){
int sum=0;
        for(int i=0;i<a.length;i++){
          sum+=a[i];  
        }
        for(int i=0;i<a.length;i++){
            if(a[i]==sum)
                return 0;
        }
    return 1;
}

//

int isIsolated(long n){
    if(n<0||n>2097151)
        return -1;
long[] squareDigits={-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
long sq=n*n;
long qu=n*n*n;
    for(long i=sq;i>0;i/=10){
    int digit=(int)i%10;
    squareDigits[digit]=digit;
    }
    for(long i=qu;i>0;i/=10){
        int digit=(int)i%10;
        if(squareDigits[digit]==digit)
                return 0;
    }
    double a=45;
return 1;
}

//

int isVanilla(int[ ] a){
    if(a.length<1)
        return 0;
    int digit=Math.abs(a[0]);
    for(int i=0;i<a.length;i++){
        for(int j=Math.abs(a[i]);j>0;j/=10){
            if(j%10!=digit)
                return 0;
        }
    
    }
return 1;
}

//

int isTrivalent (int[ ] a){
    if(a.length<1)
        return 0;
boolean fe=true,se=false,te=false;
int fv=a[0],sv=a[0],tv=a[0];
for(int i=0;i<a.length;i++)
    {
        if(te&&a[i]!=fv&&a[i]!=sv&&a[i]!=tv)
            return 0;
        else if(se&&a[i]!=fv&&a[i]!=sv)
        {
            te=true;
            tv=a[i];
        }
        else if(fe&&a[i]!=fv)
        {
            se=true;
            sv=a[i];
        }
    }
if(fe&&se&&te)
    return 1;
else 
    return 0;
}

//

int isSequentiallyBounded(int[ ] a){

    for(int i=0;i<a.length;i++)
    {
        int count=0;
        for(int j=i;j<a.length;j++)
        {
            if(a[i]==a[j])
                count++;
            else if(a[j]<a[i])
                return 0;
        }
        if(count>=a[i])
            return 0;
    }
    
return 1;
}

//

int isMinMaxDisjoint(int[ ] a){
    if(a.length<3)
        return 0;
int min=0,max=0,minOccur=0,maxOccur=0;
for(int i=0;i<a.length;i++){
    if(a[i]<=a[min]){
        if(a[i]==a[min]){
            minOccur++;
        }
        else{
            min=i;
            minOccur=1;
        }
    }
    else if(a[i]>=a[max]){
        if(a[i]==a[max])
        {
            maxOccur++;
        }
        else{
            maxOccur=1;
            max=i;
        }
    }
}
if(a[max]==a[min]||(min-1)==max||(max-1)==min||maxOccur>1||minOccur>1)
    return 0;
else return 1;
}

//

int smallest(int n){
int j=1,i=1;
for(;j<=n;i++){// the loop should exit once all the condtion in j are tested 
    for(j=1;j<=n;j++){
       int num=i*j;
       boolean exist2=false;
       for(int l=num;l>0;l/=10){
           if(l%10==2){
           exist2=true;
           break;
           }
       }
       if(!exist2){
           break;//if not exist break before j is greater than n
       }
    }
}
return (i-1);
}

//

int[ ] clusterCompression(int[ ] a){
    if(a.length<1)
        return new int[]{};
int clusterSize=1;
for(int i=0;i<(a.length-1);i++){
    if(a[i]!=a[i+1])
        clusterSize++;
}
int[] clustor=new int[clusterSize];
clustor[0]=a[0];
for(int i=0,ci=1;i<(a.length-1);i++){
    if(a[i]!=a[i+1])
    {
        clustor[ci]=a[i+1];
        ci++;
    }
}
return clustor;
}

//

int isRailroadTie(int[ ] a){
    if(a.length<2)
        return 0;
    else if(a[0]==0||a[1]==0)
        return 0;
    else if(a[a.length-1]==0||a[a.length-2]==0)
        return 0;
    for(int i=1;i<=(a.length-2);i++){
        if(a[i]==0){
            if(a[i-1]==0||a[i+1]==0)
                return 0;
        }
        else {
            if(a[i-1]==0&&a[i+1]==0)
                return 0;
            else if(a[i-1]!=0&&a[i+1]!=0)
                return 0;
        }
    }
return 1;
}


//

int fullnessQuotient(int n){
int count=0;
for(int base=2;base<10;base++){
    boolean noZero=true;
    for(int num=n;num>0;num/=base){
        if(num%base==0)
        {
            noZero=false; 
            break;
        }
    }
    if(noZero)
        count++;
}
return count;
}

//

int isPacked(int[ ] a){

for(int i=0;i<a.length;i++){
    int found=0,count=0;
    for(int j=0;j<a.length;j++){
    if(a[i]<0)
        return 0;
    else if(found==1&&a[i]!=a[j])
        found=2;
    else if(found==2&&a[i]==a[j])
        return 0;
    else if(a[j]==a[i])
    {
        found=1;
        count++;
    }
    }
    if(count!=a[i])
        return 0;
}
return 1;
}

//

int isOddHeavy(int[ ] a){
boolean odd=false;

for(int i=0;i<a.length;i++){
if(a[i]%2==0)
    continue;
for(int j=0;j<a.length;j++){
    if(a[j]%2!=0)
        continue;
    else if(a[i]<=a[j])
        return 0;
}
odd=true;
}

if(odd)
    return 1;
else 
    return 0;
}

//

int getExponent(int n, int p){
int num=0;

for(int x=1;x<n&&Math.pow(p,x)<=n;x++){

    if(n%Math.pow(p,x)==0)
        num=x;
    
}

return num;
}

//

int is121Array(int[ ] a){
int begin1=0,end1=0,middle2=0;
for(int i=0;i<a.length;i++){
    if(middle2==0&&a[i]==1)
        begin1++;
    else if(end1==0&&a[i]==2)
        middle2++;
    else if(middle2!=0&&a[i]==1)
        end1++;
    else return 0;
}
if(begin1!=end1||middle2==0)
    return 0;
return 1;
}

//

int[ ] filterArray(int[ ] a, int n){
int arraySize=0;
int index=0;
for(int num=n;num>0;num/=2){
    if(num%2!=0)
        arraySize++;
}

int[] repArray=new int[arraySize];
for(int num=n,i=0;num>0;num/=2,i++){
    if(i>=a.length)
    return new int[]{};
    if(num%2!=0){
        repArray[index]=a[i];
        index++;
    }
}
return repArray;
}

//

int largestAdjacentSum(int[ ] a){
int adjacentS=a[0]+a[1];
for(int i=1;i<(a.length-1);i++){
    if(a[i]+a[i+1]>adjacentS)
        adjacentS=a[i]+a[i+1];
}
return adjacentS;
}

//

int checkConcatenatedSum(int n, int catlen){
int sum=0;
for(int i=n;i>0;i/=10)
{
    int num=i%10;
    int termSum=0;
    int digitize=1;
    for(int j=1;j<=catlen;j++){
    termSum+=num*digitize;
    digitize*=10;
    }
    sum+=termSum;
}
if(sum==n)
    return 1;
else 
    return 0;
}

//

int isSequencedArray(int[ ] a, int m, int n){
    if(a[0]!=m||a[a.length-1]!=n)
        return 0;
for(int i=0;i<(a.length-1);i++){
    if(a[i]!=a[i+1]&&a[i+1]-a[i]!=1)
        return 0;
}
return 1;
}

//

int largestPrimeFactor(int n){
int largestPrime=0;
if(n%2==0)
    largestPrime=2;
for(int i=3;i<n;i+=2){
    if(n%i==0){
        boolean isPrime=true;
        for(int j=2;j<i;j++){
            if(i%j==0)
            {
                isPrime=false;
                break;
            }
        }
        if(isPrime){
          largestPrime=i;  
        }
    }
}
return largestPrime;
}

//

int[ ] encodeNumber(int n){
int arraySize=0;
for(int i=2,num=n;i<=n&&num>0;i++){
    if(num%i==0){
        boolean isPrime=true;
        for(int j=2;j<i;j++){
            if(i%j==0)
            {
                isPrime=false;
                break;
            }
        }
        if(isPrime){
            num=num/i;
            arraySize++;
            i--;
        }
    }
}
int[] primeArray=new int[arraySize];
for(int i=2,index=0,num=n;i<=n&&num>0;i++){
    if(num%i==0){
        boolean isPrime=true;
        for(int j=2;j<i;j++)
        {
            if(i%j==0){
                isPrime=false;
                break;
            }
        }
        if(isPrime){
            num=num/i;
        primeArray[index]=i;
        index++;
        i--;
        }
    }
}
return primeArray;
}

//

static int matchPattern(int[] a, int len, int[] pattern, int patternLen) {
// len is the number of elements in the array a, patternLen is the number of elements in the pattern.
int i=0; // index into a
int k=0; // index into pattern
int matches = 0; // how many times current pattern character has been matched so far 
for (i=0; i<len; i++) {
if (a[i] == pattern[k])
matches++; // current pattern character was matched
else if (matches == 0 || k == patternLen-1)
return 0; // if pattern[k] was never matched (matches==0) or at end of pattern (k==patternLen-1)
else // advance to next pattern character 
{
if(a[i]==pattern[k+1])
    k++;
else 
    return 0;
} // end of else 
} // end of for
// return 1 if at end of array a (i==len) and also at end of pattern (k==patternLen-1)
if (i==len && k==patternLen-1) return 1; else return 0; 
}

//

void doIntegerBasedRounding(int[ ] a, int n){
for(int i=0;i<a.length;i++){
    if(a[i]<0)
        continue;
    else if(a[i]==n)
        a[i]=n;
    else if(a[i]<n){
    int preC=0,forC=0;
    for(int j=0;j<=n;j++){
        if(j<a[i])
            preC++;
        else if(j>a[i])
            forC++;
    }
    a[i]=preC<forC?0:n;
    }
    else {
        int mult=1;
        int R=n;
        for(;mult<a[i];R++){
            mult=R*2;
        }
    int preC=0,forC=0;
    for(int l=n;l<=mult;l++){
        if(l<a[i])
            preC++;
        else if(l>a[i])
            forC++;
    }
    a[i]=preC<forC?n:mult;
    }

}

            for(int element: a){
                System.out.println(element);
            }
}

//

int isCubePowerful(int n){
    if(n<=0)
        return 1;
int sum=0;
for(int i=n;i>0;i/=10){
    int num=i%10;
    sum+=Math.pow(num,3);    
}
if(sum==n)
    return 1;
else 
    return 0;
}

//

int decodeArray(int[ ] a){
int numRep=0,digitize=1;
for(int i=(a.length-1);i>0;i--){
int num=Math.abs(a[i-1]-a[i])*digitize;
numRep+=num;
digitize*=10;
}
if(a[0]<0)
    numRep*=-1;
return numRep;
}

//

int isZeroPlentiful(int[ ] a){
boolean counting0=false;
int count=0,zeroRound=0;
for(int i=0;i<a.length;i++){
if(a[i]==0){
    counting0=true;
    count++;
    if(i==(a.length-1)){
        if(count<4)
            return 0;
        else 
            zeroRound++;
    }
        
}
else if(counting0&&a[i]!=0){
    counting0=false;
    if(count<4)
        return 0;
    count=0;
    zeroRound++;
}
}
    return zeroRound;
}

//

int isDigitIncreasing(int n){

for(int i=1;i<10;i++){
    int sum=0;
    int cSum=0;
    for(int digitize=1;cSum<n;digitize*=10){
    sum+=i*digitize;
    cSum+=sum;
    }
    if(cSum==n)
        return 1;  
}
return 0;
}

//

int decodeArray2(int[ ] a){
int num=0,digitize=1;
for(int i=0;i<a.length;i++){
    if(a[i]==1)
        digitize*=10;
}
digitize/=10;//to reverse one wrong digit place
int zeroCount=0;
    for(int i=0;i<a.length;i++){
    if(a[i]==0)
        zeroCount++;
    else if(a[i]==1)
    {
        num+=zeroCount*digitize;
        digitize/=10;
        zeroCount=0;
    }

}
    if(a[0]==-1)
        num*=-1;
return num;
}

//

int isOnionArray(int[ ] a){
int j=a.length/2-1,k=0;
if(a.length%2==0)
{
    k=a.length/2;
}
else {
   k=a.length/2+1; 
}
for(;j>=0&&k<a.length;j--,k++){
    if(a[j]+a[k]>10)
        return 0;
}
return 1;
}

//

int isPrimeHappy(int n){
    int sum=0;
for(int i=2;i<n;i++)
    {
        boolean isPrime=true;
        for(int j=2;j<i;j++)
        {
            if(i%j==0)
            {
                isPrime=false;
                break;
            }
        }
        if(isPrime){
            sum+=i;
        }
    } 
    
if(sum==0||sum%n!=0)
    return 0;
else 
    return 1;
}

//

int[] encodeArray(int n){
int size=0;
for(int i=Math.abs(n);i>0;i/=10){
    size+=(i%10)+1;
}
if(n<0)
    size++;
int[] encode=new int[size];
int j=encode.length-1;
for(int i=Math.abs(n);i>0;i/=10){
    int num=i%10;
    encode[j]=1;
    j--;
    for(int k=0;k<num;k++){
        encode[j]=0;
        j--;
    }
}
if(n<0)
    encode[j]=-1;
return encode;
}

//

int isSystematicallyIncreasing(int[ ] a){
 if(a[0]!=1)
     return 0;
int lastTop=a[a.length-1];
boolean check=false;
for(int i=(a.length-1);i>=0;i--){
    if(check){
        if(lastTop-a[i]!=1)
            return 0;
        lastTop=a[i];
        check=false;
        
    }
    else if(a[i]==1){
        check=true;
    }
   else if(a[i-1]-a[i]!=-1)
       return 0;
}
return 1;
}

//

int isFactorialPrime(int n){
for(int i=2;i<n;i++){
    if(n%i==0)
        return 0;
}
int fact=1;
for(int j=1;(fact+1)<n;j++){
    fact=1;
    for(int k=1;k<=j;k++)
        fact*=k;
}
 if((fact+1)==n)
     return 1;
 else 
     return 0;
}

//

int largestDifferenceOfEvens(int[ ] a){
int largestD=-1;
for(int i=0;i<a.length;i++){
if(a[i]%2!=0)
    continue;
for(int j=0;j<a.length;j++){
    if(a[j]%2!=0)
        continue;
    else if(a[i]-a[j]>largestD&&i!=j)
        largestD=a[i]-a[j];
}
}
return largestD;
}

//

int isHodder(int n){
    for(int j=2;j<n;j++){
        if(n%j==0)
            return 0;
    }
    int hooder=2;
    for(int k=1;(hooder-1)<n;k++)//exit the loop the moment it realize its true or false
        hooder=(int)Math.pow(2,k);
    if((hooder-1)==n)// check if the loop exit because it becomes equal
        return 1;
    return 0;
}

//

int areAnagrams(char [ ] a1, char [ ] a2){
    if(a1.length!=a2.length)
        return 0;
char[] check=a2;
for(int i=0;i<a1.length;i++){
    boolean found=false;
    for(int k=0;k<check.length;k++){
        if(a1[i]==check[k])
        {
            check[k]=00;
            found=true;
            break;  
        }
    }
   if(!found){
   return 0;
   }
}
return 1;
}

//

int closestFibonacci(int n){
int n1=1,n2=1,cf=0;
for(int i=0;cf<n;i++){
int temp=n2;
n2=n1+n2;
n1=temp;
cf=n1+n2;
}
return n2;
}


//

int minDistance(int n){
int diff=0,pf=1;
for(int i=2;i<=n;i++){
    if(n%i==0){
        if(diff==0){
            diff=i-pf;
        }
        else if((i-pf)<diff) {
            diff=i-pf;
        }
        pf=i;
    }
    if(diff==1)
        return diff;
}
return diff;
}

int isWave (int [ ] a){
boolean odd=a[0]%2!=0?true:false;
for(int i=1;i<a.length;i++){
    if(odd&&a[i]%2!=0)
        return 0;
    else if((!odd)&&a[i]%2==0)
        return 0;
    odd=(!odd);
}
return 1;
}


//


boolean sumIsPower(int[] arr) {
int sum=0;
for(int i=0;i<arr.length;i++){
	sum+=arr[i];
}
int pow=0;
for(int i=0;i<sum&&pow<sum;i++){
pow=(int)Math.pow(2,i);
}
return pow==sum;
}


}
